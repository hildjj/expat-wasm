<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>evented.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="XmlParseError.html">XmlParseError</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="XmlParser.html">XmlParser</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="XmlParser.html#.create">create</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="XmlParser.html#.version">version</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="XmlParser.html#destroy">destroy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="XmlParser.html#parse">parse</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="XmlParser.html#triple">triple</a></span></li><li class="nav-heading">Events</li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:attlistDecl">attlistDecl</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:characterData">characterData</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:comment">comment</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:elementDecl">elementDecl</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:endCdataSection">endCdataSection</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:endDoctypeDecl">endDoctypeDecl</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:endElement">endElement</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:endNamespaceDecl">endNamespaceDecl</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:entityDecl">entityDecl</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:notationDecl">notationDecl</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:processingInstruction">processingInstruction</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:startCdataSection">startCdataSection</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:startDoctypeDecl">startDoctypeDecl</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:startElement">startElement</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:startNamespaceDecl">startNamespaceDecl</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="XmlParser.html#event:xmlDecl">xmlDecl</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li>
</nav>

<div id="main">
    
    <h1 class="page-title">evented.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'
const {EventEmitter} = require('events')
const Pointers = require('./pointers')
const expat = require('./expat')
const expatInit = new Promise(resolve => {
  expat['onRuntimeInitialized'] = resolve
})
const INTERNAL = Symbol('XmlParserInternal')

/**
 * Error parsing XML
 *
 * @class XmlParseError
 * @extends {Error}
 * @property {number} code - expat error code
 * @property {string} xmlMessage - error string
 * @property {number} line - input line that caused the error
 * @property {number} column - input column that cause the error
 */
class XmlParseError extends Error {
  constructor (parser) {
    super('XML Parse Error')
    this.code = XmlParser.XML_GetErrorCode(parser)
    this.xmlMessage = XmlParser.XML_ErrorString(this.code)
    this.line = XmlParser.XML_GetCurrentLineNumber(parser)
    this.column = XmlParser.XML_GetCurrentColumnNumber(parser)
  }
}

/**
 * An evented parser based on a WASM-compiled version of expat.
 * NOTE: Please make sure to call {@link XmlParser#destroy destroy()}
 * when you are done.
 *
 * @class XmlParser
 * @extends {EventEmitter}
 */
class XmlParser extends EventEmitter {
  /**
   * Factory for creating XmlParser instances.  This approach ensures that
   * the WASM code has been loaded, initialized, and bound correctly to
   * JS before you get an object.
   *
   * @static
   * @param {string} encoding - one of null, "US-ASCII", "UTF-8", "UTF-16"
   *   or "ISO-8859-1".  null, the default, will do content sniffing.
   * @param {string} [separator='|'] - the separator for namespace URI and
   *   element/attribute name.
   * @returns {XmlParser}
   *
   * @memberOf XmlParser
   */
  static async create (encoding, separator = '|') {
    await XmlParser._initialize(INTERNAL)
    return new XmlParser(INTERNAL, encoding, separator)
  }

  /**
   * The current version of expat
   *
   * @static
   * @returns {string} the current version
   *
   * @memberOf XmlParser
   */
  static async version () {
    await XmlParser._initialize(INTERNAL)
    return this.XML_ExpatVersion()
  }

  /**
   * Initialize the WASM binding.
   *
   * @private
   * @static
   * @param {any} _internalOnly - Prove you're calling this from create.
   * @returns {Promise}
   *
   * @memberOf XmlParser
  */
  static _initialize (_internalOnly) {
    if (_internalOnly !== INTERNAL) {
      throw new Error('don\'t call _intialize directly')
    }
    if (this._intialized != null) {
      return this._intialized
    }
    this._intialized = expatInit.then(() => {
      this.pointers = new Pointers()
      this.CB_TYPES = {}

      // Bind each of the basic expat APIs
      ;[
        ['XML_ExpatVersion', 'string', []],
        ['XML_FreeContentModel', 'void', ['number', 'number']],
        ['XML_ParserCreateNS', 'number', ['string', 'number']],
        ['XML_ParserFree', 'void', ['number']],
        ['XML_Parse', 'void', ['number', 'string', 'number', 'number']],
        ['XML_SetReturnNSTriplet', 'void', ['number', 'number']],
        ['XML_ParserReset', 'void', ['number', 'string']],
        ['XML_GetErrorCode', 'number', ['number']],
        ['XML_ErrorString', 'string', ['number']],
        ['XML_GetCurrentLineNumber', 'number', ['number']],
        ['XML_GetCurrentColumnNumber', 'number', ['number']],
        ['XML_SetUserData', 'void', ['number', 'number']]
      ].forEach(([name, ret, args]) => {
        this[name] = expat.cwrap(name, ret, args)
      })

      // Create callback functions that can be reused for each of the different
      // events.  We can't use a per-parser-instance closure (which would be
      // much more idiomatic JS) because emscripten requires us to declare the
      // max number of active callbacks as a small integer.

      // The approach is to arrange for expat to call these functions with an
      // integer as the first parameter; that integer looks up the correct
      // XmlParser instance inside of Pointers, and calls the correct function
      // with the event name as the first parameter.

      this.EVENTS = [
        /**
         * DTD Attribute list defined.
         *
         * @event XmlParser#attlistDecl
         * @param {string} elname - the element name
         * @param {string} attname - the attribute name
         * @param {string} attType - the attribute type
         * @param {string} dflt - the default value
         * @param {boolean} isrequired - is the attribute required
         */
        'AttlistDecl',
        /**
         * Plain text, or text that has been generated by an entity (e.g.)
         *
         * @event XmlParser#characterData
         * @param {string} text - the text that was found
         */
        'CharacterData',
        /**
         * Comment
         *
         * @event XmlParser#comment
         * @param {string} text - the comment text
         */
        'Comment',
        /**
         * DTD Element declaration
         *
         * @event XmlParser#elementDecl
         * @param {string} name - the name of the element
         * @param {Model} model - description of the element
         */
        'ElementDecl',
        /**
         * End of a CData section
         *
         * @event XmlParser#endCdataSection
         */
        'EndCdataSection',
        /**
         * End of a DTD
         *
         * @event XmlParser#endDoctypeDecl
         */
        'EndDoctypeDecl',
        /**
         * End of an Element.
         *
         * @event XmlParser#endElement
         * @param {string} name - the name of the element.  If the element is in
         *   a namespace, the name will be URI+separator+name.
         */
        'EndElement',
        /**
         * A namespace declaration went out of scope
         *
         * @event XmlParser#endNamespaceDecl
         * @param {string} prefix - the prefix that went out of scope
         */
        'EndNamespaceDecl',
        /**
         * Notation declaration.
         *
         * @event XmlParser#notationDecl
         * @param {string} notationName
         * @param {string} base
         * @param {string} systemId
         * @param {string} publicId
         */
        'NotationDecl',
        /**
         * Processing Instruction
         *
         * @event XmlParser#processingInstruction
         * @param {string} target
         * @param {string} data
         */
        'ProcessingInstruction',
        /**
         * CDATA Section.  Expect events for child text next.
         *
         * @event XmlParser#startCdataSection
         */
        'StartCdataSection',
        /**
         * Start of a DOCTYPE
         *
         * @event XmlParser#startDoctypeDecl
         * @param {string} doctypeName
         * @param {string} sysid
         * @param {string} pubid
         * @param {boolean} hasInternalSubset
         */
        'StartDoctypeDecl',
        /**
         * Start of an Element.
         *
         * @event XmlParser#startElement
         * @param {string} name - the name of the element.  If the element is in
         *   a namespace, the name will be URI+separator+name.
         * @param {object} attribs - attributes for this element as name/value
         *   pairs.  Names are similar to element name; URI+separator+name.
         */
        'StartElement',
        /**
         * Namespace declaration comes into scope.  Fires before startElement.
         *
         * @event XmlParser#startNamespaceDecl
         * @param {string} prefix
         * @param {string} uri
         */
        'StartNamespaceDecl',
        /**
         * Declaration of an entity.
         *
         * @event XmlParser#entityDecl
         * @param {string} entityName
         * @param {boolean} is_parameter_entity
         * @param {string|null} value
         * @param {string} base
         * @param {string} systemId
         * @param {string} publicId
         * @param {string} notationName
         */
        'EntityDecl',
        /**
         * XML Declaration.
         *
         * @event XmlParser#xmlDecl
         * @param {string} version
         * @param {string} encoding
         * @param {boolean} standalone
         */
        'XmlDecl'
      ].reduce((o, s) => {
        const lc = s[0].toLowerCase() + s.slice(1)
        o[lc] = expat.cwrap(
          `XML_Set${s}Handler`,
          'void',
          ['number', 'function'])
        switch (lc) {
          // These require special processing
          case 'startElement':
          case 'characterData':
          case 'xmlDecl':
          case 'startDoctypeDecl':
          case 'elementDecl':
          case 'attlistDecl':
          case 'entityDecl':
            this.CB_TYPES[lc] = expat.addFunction(
              this.pointers.bind('_' + lc, lc))
            break
          default:
            this.CB_TYPES[lc] = expat.addFunction(
              this.pointers.bind('_simpleEvent', lc))
        }
        return o
      }, {})

      return this
    })
    return this._intialized
  }

  constructor (_internalOnly, encoding, separator) {
    if (_internalOnly !== INTERNAL) {
      throw new Error('Please use "create()" factory')
    }
    super()
    this.separator = separator
    this.parser = XmlParser.XML_ParserCreateNS(encoding, separator.charCodeAt(0))
    this.id = XmlParser.pointers.add(this)
    XmlParser.XML_SetUserData(this.parser, this.id)
    XmlParser.XML_SetReturnNSTriplet(this.parser, 1)
    for (const [k, v] of Object.entries(XmlParser.EVENTS)) {
      v(this.parser, XmlParser.CB_TYPES[k])
    }
  }

  _startElement (event, name, attr) {
    const attribs = {}
    for (let a = attr / 4; expat.HEAPU32[a]; a += 2) {
      attribs[expat.Pointer_stringify(expat.HEAPU32[a])] =
        expat.Pointer_stringify(expat.HEAPU32[a + 1])
    }
    this.emit(event, expat.Pointer_stringify(name), attribs)
  }
  _characterData (event, txt, len) {
    this.emit(event, expat.Pointer_stringify(txt, len))
  }
  _xmlDecl (event, version, encoding, standalone) {
    this.emit(event,
      expat.Pointer_stringify(version),
      expat.Pointer_stringify(encoding),
      !!standalone)
  }
  _startDoctypeDecl (event, doctypeName, sysid, pubid, internalSubset) {
    this.emit(event,
      expat.Pointer_stringify(doctypeName),
      expat.Pointer_stringify(sysid),
      expat.Pointer_stringify(pubid),
      !!internalSubset)
  }
  __chase (model, m) {
    const a = model / 4
    const [type, quant, name, numchildren, children] = expat.HEAPU32.slice(a, a+5)
    m.type = type
    m.quant = quant
    if (name) {
      m.name = expat.Pointer_stringify(name)
    }
    m.children = []
    for (let c = 0; c &lt; numchildren; c++) {
      const child = {}
      this.__chase(children + (20 * c), child)
      m.children.push(child)
    }
    return m
  }
  _elementDecl (event, name, model) {
    const m = this.__chase(model, {name: expat.Pointer_stringify(name)})
    this.emit(event, expat.Pointer_stringify(name), m)
    XmlParser.XML_FreeContentModel(this.parser, model)
  }
  _attlistDecl (event, elname, attname, attType, dflt, isrequired) {
    this.emit(
      event,
      expat.Pointer_stringify(elname),
      expat.Pointer_stringify(attname),
      expat.Pointer_stringify(attType),
      expat.Pointer_stringify(dflt),
      !!isrequired)
  }
  _entityDecl (event, entityName, isParameterEntity, value, valueLength, base, systemId, publicId, notationName) {
    this.emit(
      event,
      entityName ? expat.Pointer_stringify(entityName) : null,
      !!isParameterEntity,
      value ? expat.Pointer_stringify(value, valueLength) : null,
      base ? expat.Pointer_stringify(base) : null,
      systemId ? expat.Pointer_stringify(systemId) : null,
      publicId ? expat.Pointer_stringify(publicId) : null,
      notationName ? expat.Pointer_stringify(notationName) : null)
  }

  _simpleEvent (event, ...args) {
    this.emit(event, ...args.map(s => expat.Pointer_stringify(s)))
    return 1
  }

  /**
   * Parse a chunk of text.  If this is not the last (or only) chunk,
   * set `final` to 0.
   *
   * @param {string} chunk - Input text
   * @param {number} [final=1] - 0 if not the last or only chunk.
   *
   * @memberOf XmlParser
   * @throws {XmlParseError}
   * @fires XmlParser#attlistDecl
   * @fires XmlParser#characterData
   * @fires XmlParser#comment
   * @fires XmlParser#elementDecl
   * @fires XmlParser#endCdataSection
   * @fires XmlParser#endDoctypeDecl
   * @fires XmlParser#endElement
   * @fires XmlParser#endNamespaceDecl
   * @fires XmlParser#notationDecl
   * @fires XmlParser#processingInstruction
   * @fires XmlParser#startCdataSection
   * @fires XmlParser#startDoctypeDecl
   * @fires XmlParser#startElement
   * @fires XmlParser#startNamespaceDecl
   * @fires XmlParser#entityDecl
   * @fires XmlParser#xmlDecl
   */
  parse (chunk, final = 1) {
    const res = XmlParser.XML_Parse(this.parser, chunk, chunk.length, final)
    if (res === 0) {
      throw new XmlParseError(this.parser)
    } else if ((res === 1) &amp;&amp; (final === 1)) {
      // TODO: this doesn't work yet
      XmlParser.XML_ParserReset(this.parser, this.encoding)
    }
  }

  /**
   * @typedef {Object} Pieces
   * @property {string} pieces.ns - the namespace URI
   * @property {string} pieces.local - the local name,
   *   or the EVENTS name if no namespace
   * @property {string} pieces.prefix - the prefix used for the current name
   */
  /**
   * Parse an element or attribute name.
   *
   * @param {string} name - a EVENTS name, or a URI+local+prefix triple
   * @returns {Pieces} pieces - the pieces of the name
   *
   * @memberOf XmlParser
   */
  triple (name) {
    const [ns, local, prefix] = name.split(this.separator)
    if (!local) {
      return {
        local: ns
      }
    }
    if (!prefix) {
      return { ns, local }
    }
    return { ns, local, prefix }
  }

  /**
   * Clean up after the parser.  REQUIRED, since there is not currently
   * memory management for WASM code.
   *
   * @memberOf XmlParser
   */
  destroy () {
    XmlParser.XML_ParserFree(this.parser)
    delete this.parser
    XmlParser.pointers.remove(this.id)
    delete this.id
  }
}
module.exports = XmlParser
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
